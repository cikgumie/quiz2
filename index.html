<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Interaktif Pemikiran Komputasional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 900px;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        .header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .progress-bar {
            background: rgba(255,255,255,0.2);
            height: 8px;
            border-radius: 4px;
            margin-top: 20px;
            overflow: hidden;
        }

        .progress-fill {
            background: #FFD700;
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .game-content {
            padding: 40px;
        }

        .start-screen, .question-screen, .result-screen {
            text-align: center;
        }

        .question-screen {
            display: none;
        }

        .result-screen {
            display: none;
        }

        .question-type-badge {
            background: linear-gradient(135deg, #FF6B6B, #FF8E53);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            display: inline-block;
            margin-bottom: 20px;
        }

        .question-counter {
            background: #f0f0f0;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            margin-bottom: 30px;
            font-weight: bold;
            color: #666;
        }

        .question {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 30px;
            line-height: 1.6;
            color: #333;
        }

        /* Multiple Choice Styles */
        .options {
            display: grid;
            gap: 15px;
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .option {
            background: #f8f9fa;
            border: 3px solid #e9ecef;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            text-align: left;
            position: relative;
            overflow: hidden;
            padding: 20px 40px;
            text-align: center;
        }

        .option:hover {
            border-color: #4CAF50;
            background: #f0f8f0;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.2);
        }

        .option.selected {
            border-color: #4CAF50;
            background: #e8f5e8;
        }

        .option.correct {
            border-color: #4CAF50;
            background: #d4edda;
            animation: correctPulse 0.6s ease;
        }

        .option.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            animation: incorrectShake 0.6s ease;
        }

        /* Drag and Drop Styles */
        .drag-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .drag-items, .drop-zones {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            min-height: 300px;
        }

        .drag-items h4, .drop-zones h4 {
            text-align: center;
            margin-bottom: 20px;
            color: #666;
            font-size: 1.1em;
        }

        .drag-item {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            cursor: grab;
            user-select: none;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 600;
        }

        .drag-item:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .drag-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .drop-zone {
            border: 3px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .drop-zone.drag-over {
            border-color: #4CAF50;
            background: #f0f8f0;
        }

        .drop-zone.filled {
            background: #e8f5e8;
            border-color: #4CAF50;
        }

        .drop-zone.correct {
            background: #d4edda;
            border-color: #28a745;
        }

        .drop-zone.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .drop-zone-label {
            position: absolute;
            top: -10px;
            left: 15px;
            background: white;
            padding: 5px 10px;
            font-size: 0.9em;
            font-weight: bold;
            color: #666;
            border-radius: 5px;
        }

        /* Enhanced Matching Styles with Different Colors */
        .matching-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .matching-column {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
        }

      .matching-item {
            position: relative;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
}   

        .matching-item:hover {
            border-color: #4CAF50;
            transform: translateX(5px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        /* Color coding for matching pairs */
        .matching-item.color-1 {
            border-color: #e74c3c;
            background: linear-gradient(135deg, #ffeaea, #fff);
            color: #c0392b;
        }

        .matching-item.color-2 {
            border-color: #3498db;
            background: linear-gradient(135deg, #e8f4fd, #fff);
            color: #2980b9;
        }

        .matching-item.color-3 {
            border-color: #f39c12;
            background: linear-gradient(135deg, #fef5e7, #fff);
            color: #d68910;
        }

        .matching-item.color-4 {
            border-color: #9b59b6;
            background: linear-gradient(135deg, #f4ecf7, #fff);
            color: #8e44ad;
        }

       .matching-item.selected {
    border-color: #4CAF50;
    background: #f0f8f0;
    transform: translateX(5px);
}
       .matching-item.matched {
    border-width: 3px;}

        .matching-item.matched::after {
            content: '✓';
            position: absolute;
            top: 5px;
            right: 10px;
            background: #28a745;
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        .matching-item.correct-match {
            border-color: #28a745;
            background: linear-gradient(135deg, #d4edda, #fff);
            animation: correctPulse 0.6s ease;
        }

        .matching-item.incorrect-match {
            border-color: #dc3545;
            background: linear-gradient(135deg, #f8d7da, #fff);
            animation: incorrectShake 0.6s ease;
        }

        /* Fill in the Blank Styles */
        .fill-blank-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            font-size: 1.2em;
            line-height: 1.8;
        }

        .blank-input {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 1em;
            margin: 0 5px;
            min-width: 120px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .blank-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .blank-input.correct {
            border-color: #28a745;
            background: #d4edda;
        }

        .blank-input.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            animation: incorrectShake 0.6s ease;
        }

        .word-bank {
            background: #e7f3ff;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .word-bank h4 {
            margin-bottom: 15px;
            color: #007bff;
        }

        .word-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .word-option {
            background: #007bff;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .word-option:hover {
            background: #0056b3;
            transform: scale(1.05);
        }

        .word-option.used {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Common Styles */
        .btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .explanation {
            background: #e7f3ff;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: left;
            border-left: 5px solid #007bff;
        }

        .explanation h4 {
            color: #007bff;
            margin-bottom: 10px;
        }

        /* Animations */
        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Result Screen Styles */
        .score {
            font-size: 3em;
            font-weight: bold;
            color: #4CAF50;
            margin: 20px 0;
        }

        .feedback {
            font-size: 1.2em;
            margin: 20px 0;
            padding: 20px;
            border-radius: 15px;
            font-weight: 600;
        }

        .feedback.excellent {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .feedback.good {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .feedback.average {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .drag-container, .matching-container {
                grid-template-columns: 1fr;
            }
            
            .word-options {
                justify-content: center;
            }
        }
        /* Add to your existing CSS */
.matching-item {
    position: relative;
    padding-left: 40px;
}

.item-number {
    font-weight: bold;
    margin-right: 10px;
    color: #555;
}


.matching-item.selected {
    transform: translateX(8px) scale(1.02);
    box-shadow: 0 5px 20px rgba(76, 175, 80, 0.3);
    border-width: 4px;
    background-color: #e3f2fd !important;
}

.matching-item.highlight {
    animation: pulse 1s infinite;
}

.matching-item.matched {
    position: relative;
    padding-right: 40px;
}

.matching-item.matched::after {
    content: '✓';
    position: absolute;
    top: 50%;
    right: 10px;
    transform: translateY(-50%);
    background: #28a745;
    color: white;
    border-radius: 50%;
    width: 25px;
    height: 25px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
}

.connection-line {
    position: absolute;
    height: 2px;
    background: #4CAF50;
    z-index: 1;
    pointer-events: none;
    opacity: 0.7;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); }
    70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
}
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>🧠 Quiz Interaktif Pemikiran Komputasional</h1>
            <p>Tingkatan 3 - BAB 1: Konsep Asas Pemikiran Komputasional</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
        </div>

        <div class="game-content">
            <!-- Start Screen -->
            <div class="start-screen" id="startScreen">
                <h2>🎯 Selamat Datang ke Quiz Interaktif!</h2>
                <p style="font-size: 1.2em; margin: 30px 0; color: #666;">
                    Uji pengetahuan anda dengan pelbagai jenis soalan interaktif
                </p>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number">12</div>
                        <div>Soalan</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">5</div>
                        <div>Jenis Soalan</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">⏱️</div>
                        <div>Tiada Had Masa</div>
                    </div>
                </div>
                <div style="margin: 20px 0; font-size: 1.1em; color: #555;">
                    <p><strong>Jenis Soalan:</strong></p>
                    <p>🔘 Pilihan Berganda • 🔄 Drag & Drop • 🔗 Matching • ✏️ Fill in the Blank • ✅ True/False</p>
                </div>
                <button class="btn" onclick="startQuiz()">🚀 Mula Quiz</button>
            </div>

            <!-- Question Screen -->
            <div class="question-screen" id="questionScreen">
                <div class="question-type-badge" id="questionType">Pilihan Berganda</div>
                <div class="question-counter" id="questionCounter">Soalan 1 dari 12</div>
                <div class="question" id="questionText">Soalan akan dipaparkan di sini</div>
                <div id="questionContainer">
                    <!-- Question content will be dynamically inserted here -->
                </div>
                <button class="btn" id="nextBtn" onclick="checkAnswer()" disabled>Semak Jawapan</button>
            </div>

            <!-- Result Screen -->
            <div class="result-screen" id="resultScreen">
                <h2>🎉 Tahniah! Quiz Selesai!</h2>
                <div class="score" id="finalScore">0/12</div>
                <div class="feedback" id="feedbackMessage"></div>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number" id="correctAnswers">0</div>
                        <div>Betul</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="wrongAnswers">0</div>
                        <div>Salah</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="percentage">0%</div>
                        <div>Peratusan</div>
                    </div>
                </div>
                <button class="btn" onclick="restartQuiz()">🔄 Main Lagi</button>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            {
                type: 'multiple-choice',
                question: "Siapakah individu pertama yang memperkenalkan pemikiran komputasional untuk pembelajaran?",
                options: ["Alan Turing", "Seymour Papert", "John von Neumann", "Charles Babbage"],
                correct: 1,
                explanation: "Seymour Papert merupakan individu pertama yang memperkenalkan pemikiran komputasional untuk pembelajaran."
            },
            {
                type: 'drag-drop',
                question: "Susunkan fasa pembangunan atur cara mengikut urutan yang betul:",
                dragItems: ["Pengujian dan Penyahpepijatan", "Pengekodan", "Analisis Masalah", "Dokumentasi", "Reka Bentuk Atur Cara"],
                dropZones: ["Fasa 1", "Fasa 2", "Fasa 3", "Fasa 4", "Fasa 5"],
                correctOrder: [2, 4, 1, 0, 3], // indices of dragItems in correct order
                explanation: "Urutan yang betul: 1) Analisis Masalah, 2) Reka Bentuk Atur Cara, 3) Pengekodan, 4) Pengujian dan Penyahpepijatan, 5) Dokumentasi."
            },
            {
                type: 'matching',
                question: "Padankan teknik pemikiran komputasional dengan deskripsinya:",
                leftItems: ["Leraian", "Pengecaman Corak", "Peniskalaan", "Pengitlakan"],
                rightItems: [
                    "Memecahkan masalah besar kepada bahagian kecil",
                    "Menganalisis untuk mengecam corak tertentu", 
                    "Fokus pada aspek penting sahaja",
                    "Menulis algoritma untuk menyelesaikan masalah"
                ],
                correctMatches: [0, 1, 2, 3], // indices showing correct pairs
                explanation: "Setiap teknik pemikiran komputasional mempunyai peranan khusus dalam menyelesaikan masalah secara sistematik."
            },
            {
                type: 'fill-blank',
                question: "Lengkapkan ayat berikut:",
                text: "Pemikiran komputasional ditakrifkan sebagai satu proses pemikiran bertujuan untuk _____ masalah oleh manusia sendiri berbantukan _____ atau kedua-duanya sekali menggunakan konsep asas _____.",
                blanks: ["menyelesaikan", "mesin", "sains komputer"],
                wordBank: ["menyelesaikan", "mesin", "sains komputer", "teknologi", "komputer", "algoritma"],
                explanation: "Definisi lengkap: Pemikiran komputasional adalah proses pemikiran untuk menyelesaikan masalah dengan bantuan mesin menggunakan konsep asas sains komputer."
            },
            {
                type: 'true-false',
                question: "Ralat sintaks akan menyebabkan atur cara terhenti tiba-tiba semasa pelaksanaan.",
                correct: false,
                explanation: "SALAH. Ralat sintaks akan dikesan sebelum atur cara dijalankan. Ralat yang menyebabkan atur cara terhenti tiba-tiba semasa pelaksanaan adalah ralat masa larian (runtime error)."
            },
            {
                type: 'multiple-choice',
                question: "Manakah contoh ralat logik?",
                options: ["Tertinggal tanda kurung", "Pembahagian dengan sifar", "Kesalahan formula pengiraan", "Penggunaan pemboleh ubah tidak wujud"],
                correct: 2,
                explanation: "Ralat logik disebabkan kesilapan logik pengatur cara seperti kesalahan formula pengiraan, menyebabkan output salah tetapi program masih berjalan."
            },
            {
                type: 'drag-drop',
                question: "Kategorikan jenis ralat berikut kepada kategori yang sesuai:",
                dragItems: ["Tertinggal tanda kurung", "Pembahagian sifar", "Formula salah", "Salah eja kata kunci"],
                dropZones: ["Ralat Sintaks", "Ralat Masa Larian", "Ralat Logik"],
                correctAssignment: [0, 1, 2, 0], // which drop zone each item belongs to
                explanation: "Ralat Sintaks: kesalahan tatabahasa kod. Ralat Masa Larian: program terhenti tiba-tiba. Ralat Logik: output salah tetapi program berjalan."
            },
            {
                type: 'fill-blank',
                question: "Lengkapkan pernyataan tentang dokumentasi:",
                text: "Dokumentasi _____ adalah rujukan untuk pengatur cara baharu dalam organisasi, manakala dokumentasi _____ digunakan oleh pengguna akhir dan terbahagi kepada dokumen _____ dan panduan _____.",
                blanks: ["dalaman", "luaran", "pustaka", "pengguna"],
                wordBank: ["dalaman", "luaran", "pustaka", "pengguna", "sistem", "teknikal"],
                explanation: "Dokumentasi dalaman untuk pengatur cara, dokumentasi luaran untuk pengguna akhir (dokumen pustaka dan panduan pengguna)."
            },
            {
                type: 'matching',
                question: "Padankan aktiviti dengan fasa pembangunan yang sesuai:",
                leftItems: ["Temu bual pengguna", "Menulis pseudokod", "Debugging program", "Menulis komen kod"],
                rightItems: ["Fasa Analisis Masalah", "Fasa Reka Bentuk", "Fasa Pengujian", "Fasa Dokumentasi"],
                correctMatches: [0, 1, 2, 3],
                explanation: "Setiap fasa mempunyai aktiviti khusus: Analisis (temu bual), Reka Bentuk (pseudokod), Pengujian (debugging), Dokumentasi (komen)."
            },
            {
                type: 'true-false',
                question: "Hour of Code adalah kempen yang dianjurkan oleh KPM dan MDEC untuk mendedahkan murid kepada pengekodan.",
                correct: true,
                explanation: "BETUL. Hour of Code adalah kempen KPM dan MDEC bertujuan mendedahkan dan meningkatkan kesedaran murid terhadap pengekodan, pengaturcaraan, dan sains komputer."
            },
            {
                type: 'multiple-choice',
                question: "Manakah mesej ralat yang menunjukkan TypeError dalam Python?",
                options: ["invalid syntax", "division by zero", "must be str, not float", "name 'x' is not defined"],
                correct: 2,
                explanation: "TypeError: must be str, not float muncul apabila mencantumkan jenis data yang tidak serasi, seperti menggabungkan string dengan float menggunakan operator +."
            },
            {
                type: 'fill-blank',
                question: "Lengkapkan pernyataan tentang teknik pemikiran komputasional:",
                text: "Teknik _____ digunakan untuk menganalisis masalah dengan memecahkan masalah besar kepada bahagian-bahagian kecil. Setelah itu, teknik _____ membantu mengecam corak tertentu dalam setiap bahagian kecil.",
                blanks: ["leraian", "pengecaman corak"],
                wordBank: ["leraian", "pengecaman corak", "peniskalaan", "pengitlakan", "analisis", "sintesis"],
                explanation: "Leraian memecahkan masalah besar, kemudian pengecaman corak mencari persamaan dan pola untuk penyelesaian yang lebih efisien."
            }
        ];

        let currentQuestion = 0;
        let score = 0;
        let userAnswers = [];
        let selectedAnswer = null;
        let dragDropAnswers = {};
        let matchingAnswers = {};
        let fillBlankAnswers = [];
        let selectedLeftItem = null;

        // Color schemes for matching
        const matchingColors = ['color-1', 'color-2', 'color-3', 'color-4'];

        function startQuiz() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('questionScreen').style.display = 'block';
            currentQuestion = 0;
            score = 0;
            userAnswers = [];
            selectedAnswer = null;
            showQuestion();
        }

        function showQuestion() {
            const question = questions[currentQuestion];
            document.getElementById('questionCounter').textContent = `Soalan ${currentQuestion + 1} dari ${questions.length}`;
            document.getElementById('questionText').textContent = question.question;
            
            // Set question type badge
            const typeNames = {
                'multiple-choice': '🔘 Pilihan Berganda',
                'drag-drop': '🔄 Drag & Drop', 
                'matching': '🔗 Matching',
                'fill-blank': '✏️ Fill in the Blank',
                'true-false': '✅ True/False'
            };
            document.getElementById('questionType').textContent = typeNames[question.type];
            
            // Clear previous content
            const container = document.getElementById('questionContainer');
            container.innerHTML = '';
            
            // Reset button
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.textContent = 'Semak Jawapan';
            nextBtn.onclick = checkAnswer;
            nextBtn.disabled = true;
            
            // Create question based on type
            switch(question.type) {
                case 'multiple-choice':
                    createMultipleChoice(question, container);
                    break;
                case 'drag-drop':
                    createDragDrop(question, container);
                    break;
                case 'matching':
                    createMatching(question, container);
                    break;
                case 'fill-blank':
                    createFillBlank(question, container);
                    break;
                case 'true-false':
                    createTrueFalse(question, container);
                    break;
            }
            
            // Update progress bar
            const progress = (currentQuestion / questions.length) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function createMultipleChoice(question, container) {
            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'options';
            
            question.options.forEach((option, index) => {
                                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                optionDiv.textContent = option;
                optionDiv.onclick = function() {
                    // Remove selected class from all options
                    document.querySelectorAll('.option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    // Add selected class to clicked option
                    this.classList.add('selected');
                    selectedAnswer = index;
                    document.getElementById('nextBtn').disabled = false;
                };
                optionsDiv.appendChild(optionDiv);
            });
            
            container.appendChild(optionsDiv);
        }

        function createDragDrop(question, container) {
            const dragContainer = document.createElement('div');
            dragContainer.className = 'drag-container';
            
            // Create drag items section
            const dragItemsDiv = document.createElement('div');
            dragItemsDiv.className = 'drag-items';
            
            const dragItemsTitle = document.createElement('h4');
            dragItemsTitle.textContent = 'Item untuk Drag';
            dragItemsDiv.appendChild(dragItemsTitle);
            
            question.dragItems.forEach((item, index) => {
                const dragItem = document.createElement('div');
                dragItem.className = 'drag-item';
                dragItem.textContent = item;
                dragItem.draggable = true;
                dragItem.id = 'drag-' + index;
                
                dragItem.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', this.id);
                    this.classList.add('dragging');
                });
                
                dragItem.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                });
                
                dragItemsDiv.appendChild(dragItem);
            });
            
            // Create drop zones section
            const dropZonesDiv = document.createElement('div');
            dropZonesDiv.className = 'drop-zones';
            
            const dropZonesTitle = document.createElement('h4');
            dropZonesTitle.textContent = 'Drop Zones';
            dropZonesDiv.appendChild(dropZonesTitle);
            
            question.dropZones.forEach((zone, index) => {
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone';
                dropZone.id = 'drop-' + index;
                
                const zoneLabel = document.createElement('div');
                zoneLabel.className = 'drop-zone-label';
                zoneLabel.textContent = zone;
                dropZone.appendChild(zoneLabel);
                
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drag-over');
                });
                
                dropZone.addEventListener('dragleave', function() {
                    this.classList.remove('drag-over');
                });
                
                dropZone.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');
                    
                    const dragItemId = e.dataTransfer.getData('text/plain');
                    const dragItem = document.getElementById(dragItemId);
                    
                    // Remove from any existing drop zone
                    if (dragItem.parentNode.classList.contains('drop-zone')) {
                        dragItem.parentNode.removeChild(dragItem);
                    }
                    
                    // Clear this drop zone
                    while (this.firstChild) {
                        if (this.firstChild.classList.contains('drag-item')) {
                            dragItemsDiv.appendChild(this.firstChild);
                        } else {
                            break;
                        }
                    }
                    
                    // Add to this drop zone
                    this.appendChild(dragItem);
                    dragItem.classList.remove('dragging');
                    
                    // Update answers
                    updateDragDropAnswers();
                    checkDragDropComplete();
                });
                
                dropZonesDiv.appendChild(dropZone);
            });
            
            dragContainer.appendChild(dragItemsDiv);
            dragContainer.appendChild(dropZonesDiv);
            container.appendChild(dragContainer);
            
            // Initialize dragDropAnswers
            dragDropAnswers = {};
        }

        function updateDragDropAnswers() {
            const question = questions[currentQuestion];
            dragDropAnswers = {};
            
            question.dropZones.forEach((zone, zoneIndex) => {
                const dropZone = document.getElementById('drop-' + zoneIndex);
                const dragItem = dropZone.querySelector('.drag-item');
                
                if (dragItem) {
                    const itemIndex = parseInt(dragItem.id.split('-')[1]);
                    dragDropAnswers[zoneIndex] = itemIndex;
                }
            });
        }

        function checkDragDropComplete() {
            const question = questions[currentQuestion];
            let complete = true;
            
            // Check if all drop zones are filled
            if (question.correctOrder) {
                // For ordered questions (like phases)
                complete = Object.keys(dragDropAnswers).length === question.dropZones.length;
            } else {
                // For categorized questions (like error types)
                complete = Object.keys(dragDropAnswers).length === question.dragItems.length;
            }
            
            document.getElementById('nextBtn').disabled = !complete;
        }

function createMatching(question, container) {
    const matchingContainer = document.createElement('div');
    matchingContainer.className = 'matching-container';
    
    // Left column
    const leftColumn = document.createElement('div');
    leftColumn.className = 'matching-column';
    
    const leftTitle = document.createElement('h4');
    leftTitle.textContent = 'Item';
    leftColumn.appendChild(leftTitle);
    
    question.leftItems.forEach((item, index) => {
        const matchingItem = document.createElement('div');
        matchingItem.className = 'matching-item';
        matchingItem.innerHTML = `<span class="item-number">${index + 1}.</span> ${item}`;
        matchingItem.dataset.index = index;
        
        matchingItem.addEventListener('click', function() {
            // Deselect all left items
            document.querySelectorAll('.matching-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Select this item
            this.classList.add('selected');
            selectedLeftItem = index;
        });
        
        leftColumn.appendChild(matchingItem);
    });
    
    // Right column
    const rightColumn = document.createElement('div');
    rightColumn.className = 'matching-column';
    
    const rightTitle = document.createElement('h4');
    rightTitle.textContent = 'Description';
    rightColumn.appendChild(rightTitle);
    
    question.rightItems.forEach((item, index) => {
        const matchingItem = document.createElement('div');
        matchingItem.className = 'matching-item';
        matchingItem.innerHTML = `<span class="item-number">${index + 1}.</span> ${item}`;
        matchingItem.dataset.index = index;
        
        matchingItem.addEventListener('click', function() {
            if (selectedLeftItem !== null) {
                // Check if this right item is already matched
                const alreadyMatched = Object.values(matchingAnswers).includes(index);
                
                if (!alreadyMatched) {
                    // Remove any existing match for this left item
                    if (matchingAnswers[selectedLeftItem] !== undefined) {
                        const prevRightIndex = matchingAnswers[selectedLeftItem];
                        document.querySelector(`.matching-item[data-index="${prevRightIndex}"]`).classList.remove('matched');
                        document.querySelector(`.matching-item[data-index="${selectedLeftItem}"]`).classList.remove('matched');
                    }
                    
                    // Create new match
                    matchingAnswers[selectedLeftItem] = index;
                    
                    // Add color to matched pair
                    const colorClass = matchingColors[(selectedLeftItem % matchingColors.length)];
                    
                    // Mark both items as matched with color
                    const leftItem = document.querySelector(`.matching-item[data-index="${selectedLeftItem}"]`);
                    leftItem.classList.add('matched', colorClass);
                    this.classList.add('matched', colorClass);
                    
                    // Deselect
                    selectedLeftItem = null;
                    document.querySelectorAll('.matching-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    // Check if all items are matched
                    checkMatchingComplete();
                }
            }
        });
        
        rightColumn.appendChild(matchingItem);
    });
    
    matchingContainer.appendChild(leftColumn);
    matchingContainer.appendChild(rightColumn);
    container.appendChild(matchingContainer);
    
    // Initialize matchingAnswers
    matchingAnswers = {};
}

function createConnectionLine(leftItem, rightItem) {
    // Remove any existing line for these items
    document.querySelectorAll('.connection-line').forEach(line => {
        if (line.dataset.left == leftItem.dataset.index || line.dataset.right == rightItem.dataset.index) {
            line.remove();
        }
    });
    
    const line = document.createElement('div');
    line.className = 'connection-line';
    line.dataset.left = leftItem.dataset.index;
    line.dataset.right = rightItem.dataset.index;
    
    const leftRect = leftItem.getBoundingClientRect();
    const rightRect = rightItem.getBoundingClientRect();
    const containerRect = leftItem.parentNode.parentNode.getBoundingClientRect();
    
    const lineLength = Math.sqrt(
        Math.pow(rightRect.left - leftRect.right, 2) + 
        Math.pow(rightRect.top - leftRect.top, 2)
    );
    
    const lineAngle = Math.atan2(
        rightRect.top - leftRect.top,
        rightRect.left - leftRect.left
    ) * 180 / Math.PI;
    
    line.style.width = `${lineLength}px`;
    line.style.left = `${leftRect.right - containerRect.left}px`;
    line.style.top = `${leftRect.top + leftRect.height/2 - containerRect.top}px`;
    line.style.transform = `rotate(${lineAngle}deg)`;
    line.style.transformOrigin = '0 0';
    
    leftItem.parentNode.parentNode.appendChild(line);
}

        function checkMatchingComplete() {
            const question = questions[currentQuestion];
            document.getElementById('nextBtn').disabled = Object.keys(matchingAnswers).length !== question.leftItems.length;
        }

        function createFillBlank(question, container) {
            const fillBlankContainer = document.createElement('div');
            fillBlankContainer.className = 'fill-blank-container';
            
            // Split the text by blanks and create input fields
            const parts = question.text.split(/(_____)/);
            fillBlankAnswers = new Array(question.blanks.length).fill('');
            
            parts.forEach((part, index) => {
                if (part === '_____') {
                    const blankIndex = Math.floor(index / 2);
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'blank-input';
                    input.dataset.index = blankIndex;
                    input.placeholder = 'Isikan jawapan';
                    
                    input.addEventListener('input', function() {
                        fillBlankAnswers[this.dataset.index] = this.value.trim();
                        checkFillBlankComplete();
                    });
                    
                    fillBlankContainer.appendChild(input);
                } else {
                    const textSpan = document.createElement('span');
                    textSpan.textContent = part;
                    fillBlankContainer.appendChild(textSpan);
                }
            });
            
            // Add word bank if available
            if (question.wordBank) {
                const wordBankDiv = document.createElement('div');
                wordBankDiv.className = 'word-bank';
                
                const wordBankTitle = document.createElement('h4');
                wordBankTitle.textContent = 'Word Bank';
                wordBankDiv.appendChild(wordBankTitle);
                
                const wordOptionsDiv = document.createElement('div');
                wordOptionsDiv.className = 'word-options';
                
                question.wordBank.forEach((word, index) => {
                    const wordOption = document.createElement('div');
                    wordOption.className = 'word-option';
                    wordOption.textContent = word;
                    
                    wordOption.addEventListener('click', function() {
                        // Find the first empty blank
                        const emptyBlankIndex = fillBlankAnswers.findIndex(answer => answer === '');
                        if (emptyBlankIndex !== -1) {
                            // Fill the blank
                            fillBlankAnswers[emptyBlankIndex] = word;
                            
                            // Update the input
                            const inputs = document.querySelectorAll('.blank-input');
                            inputs[emptyBlankIndex].value = word;
                            
                            // Mark word as used
                            this.classList.add('used');
                            
                            checkFillBlankComplete();
                        }
                    });
                    
                    wordOptionsDiv.appendChild(wordOption);
                });
                
                wordBankDiv.appendChild(wordOptionsDiv);
                fillBlankContainer.appendChild(wordBankDiv);
            }
            
            container.appendChild(fillBlankContainer);
        }

        function checkFillBlankComplete() {
            const question = questions[currentQuestion];
            document.getElementById('nextBtn').disabled = fillBlankAnswers.some(answer => answer === '');
        }

        function createTrueFalse(question, container) {
    const optionsDiv = document.createElement('div');
    optionsDiv.className = 'options';
    
    ['Benar', 'Salah'].forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'option';
        optionDiv.textContent = option;
        optionDiv.onclick = function() {
            // Remove selected class from all options
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });
            // Add selected class to clicked option
            this.classList.add('selected');
            selectedAnswer = index === 0; // true for index 0 (Benar), false for index 1 (Salah)
            document.getElementById('nextBtn').disabled = false;
        };
        optionsDiv.appendChild(optionDiv);
    });
    
    container.appendChild(optionsDiv);
}

     function checkAnswer() {
        const question = questions[currentQuestion];
        let isCorrect = false;
        
        switch(question.type) {
            case 'multiple-choice':
                isCorrect = selectedAnswer === question.correct;
                highlightSelectedOption(isCorrect);
                break;
            case 'true-false':
                // Fixed true/false comparison
                isCorrect = (selectedAnswer === question.correct);
                highlightSelectedOption(isCorrect);
                break;
            case 'drag-drop':
                if (question.correctOrder) {
                    isCorrect = checkDragDropOrder();
                } else {
                    isCorrect = checkDragDropCategories();
                }
                highlightDragDrop(isCorrect);
                break;
            case 'matching':
                isCorrect = checkMatchingPairs();
                highlightMatching(isCorrect);
                break;
            case 'fill-blank':
                isCorrect = checkFillBlank();
                highlightFillBlank(isCorrect);
                break;
        }
            
            // Update score and store user answer
            if (isCorrect) {
                score++;
            }
            
            userAnswers[currentQuestion] = {
                question: question.question,
                userAnswer: getCurrentUserAnswer(),
                correctAnswer: getCorrectAnswer(question),
                isCorrect: isCorrect,
                explanation: question.explanation
            };
            
            // Show explanation
            showExplanation(question.explanation);
            
            // Change button to go to next question
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.textContent = currentQuestion < questions.length - 1 ? 'Soalan Seterusnya' : 'Lihat Keputusan';
            nextBtn.onclick = nextQuestion;
            nextBtn.disabled = false;
        }

        function highlightSelectedOption(isCorrect) {
            const options = document.querySelectorAll('.option');
            options.forEach(option => option.classList.remove('selected', 'correct', 'incorrect'));
            
            if (selectedAnswer !== null) {
                const selectedOption = options[selectedAnswer];
                selectedOption.classList.add(isCorrect ? 'correct' : 'incorrect');
                
                if (!isCorrect) {
                    // Also show correct answer
                    const correctOption = options[questions[currentQuestion].correct];
                    correctOption.classList.add('correct');
                }
            }
        }

        function checkDragDropOrder() {
            const question = questions[currentQuestion];
            let allCorrect = true;
            
            question.dropZones.forEach((zone, zoneIndex) => {
                const itemIndex = dragDropAnswers[zoneIndex];
                if (itemIndex !== question.correctOrder[zoneIndex]) {
                    allCorrect = false;
                }
            });
            
            return allCorrect;
        }

        function checkDragDropCategories() {
            const question = questions[currentQuestion];
            let allCorrect = true;
            
            Object.entries(dragDropAnswers).forEach(([zoneIndex, itemIndex]) => {
                if (question.correctAssignment[itemIndex] != zoneIndex) {
                    allCorrect = false;
                }
            });
            
            return allCorrect;
        }

        function highlightDragDrop(isCorrect) {
            const question = questions[currentQuestion];
            
            if (question.correctOrder) {
                // For ordered questions
                question.dropZones.forEach((zone, zoneIndex) => {
                    const dropZone = document.getElementById('drop-' + zoneIndex);
                    const itemIndex = dragDropAnswers[zoneIndex];
                    
                    if (itemIndex === question.correctOrder[zoneIndex]) {
                        dropZone.classList.add('correct');
                    } else {
                        dropZone.classList.add('incorrect');
                        
                        // Show correct answer
                        const correctItem = document.getElementById('drag-' + question.correctOrder[zoneIndex]);
                        const correctDropZone = document.getElementById('drop-' + zoneIndex);
                        
                        // Temporarily show correct answer
                        const correctClone = correctItem.cloneNode(true);
                        correctClone.style.opacity = '0.5';
                        correctClone.style.borderStyle = 'dashed';
                        correctDropZone.appendChild(correctClone);
                    }
                });
            } else {
                // For categorized questions
                question.dragItems.forEach((item, itemIndex) => {
                    const dragItem = document.getElementById('drag-' + itemIndex);
                    const zoneIndex = dragDropAnswers[Object.keys(dragDropAnswers).find(key => dragDropAnswers[key] == itemIndex)];
                    
                    if (question.correctAssignment[itemIndex] == zoneIndex) {
                        dragItem.parentNode.classList.add('correct');
                    } else {
                        dragItem.parentNode.classList.add('incorrect');
                        
                        // Show correct category
                        const correctZoneIndex = question.correctAssignment[itemIndex];
                        const correctDropZone = document.getElementById('drop-' + correctZoneIndex);
                        
                        // Temporarily show correct answer
                        const correctClone = dragItem.cloneNode(true);
                        correctClone.style.opacity = '0.5';
                        correctClone.style.borderStyle = 'dashed';
                        correctDropZone.appendChild(correctClone);
                    }
                });
            }
        }

        function checkMatchingPairs() {
            const question = questions[currentQuestion];
            let allCorrect = true;
            
            question.correctMatches.forEach((correctRightIndex, leftIndex) => {
                if (matchingAnswers[leftIndex] !== correctRightIndex) {
                    allCorrect = false;
                }
            });
            
            return allCorrect;
        }

        function highlightMatching(isCorrect) {
            const question = questions[currentQuestion];
            
            question.leftItems.forEach((item, leftIndex) => {
                const leftItem = document.querySelector(`.matching-item[data-index="${leftIndex}"]`);
                const rightIndex = matchingAnswers[leftIndex];
                
                if (rightIndex !== undefined) {
                    const rightItem = document.querySelector(`.matching-item[data-index="${rightIndex}"]`);
                    
                    if (rightIndex === question.correctMatches[leftIndex]) {
                        leftItem.classList.add('correct-match');
                        rightItem.classList.add('correct-match');
                    } else {
                        leftItem.classList.add('incorrect-match');
                        rightItem.classList.add('incorrect-match');
                        
                        // Show correct match
                        const correctRightIndex = question.correctMatches[leftIndex];
                        const correctRightItem = document.querySelector(`.matching-item[data-index="${correctRightIndex}"]`);
                        
                        correctRightItem.style.boxShadow = '0 0 0 3px #28a745';
                        setTimeout(() => {
                            correctRightItem.style.boxShadow = '';
                        }, 2000);
                    }
                }
            });
        }

        function checkFillBlank() {
            const question = questions[currentQuestion];
            let allCorrect = true;
            
            question.blanks.forEach((blank, index) => {
                if (fillBlankAnswers[index].toLowerCase() !== blank.toLowerCase()) {
                    allCorrect = false;
                }
            });
            
            return allCorrect;
        }

        function highlightFillBlank(isCorrect) {
            const inputs = document.querySelectorAll('.blank-input');
            
            inputs.forEach((input, index) => {
                const userAnswer = fillBlankAnswers[index].toLowerCase();
                const correctAnswer = questions[currentQuestion].blanks[index].toLowerCase();
                
                if (userAnswer === correctAnswer) {
                    input.classList.add('correct');
                } else {
                    input.classList.add('incorrect');
                    
                    // Temporarily show correct answer
                    const originalValue = input.value;
                    input.value = questions[currentQuestion].blanks[index];
                    input.style.color = '#28a745';
                    input.style.fontWeight = 'bold';
                    
                    setTimeout(() => {
                        input.value = originalValue;
                        input.style.color = '';
                        input.style.fontWeight = '';
                    }, 2000);
                }
            });
        }

        function showExplanation(text) {
            const explanationDiv = document.createElement('div');
            explanationDiv.className = 'explanation';
            
            const explanationTitle = document.createElement('h4');
            explanationTitle.textContent = 'Penjelasan';
            explanationDiv.appendChild(explanationTitle);
            
            const explanationText = document.createElement('p');
            explanationText.textContent = text;
            explanationDiv.appendChild(explanationText);
            
            document.getElementById('questionContainer').appendChild(explanationDiv);
        }

        function getCurrentUserAnswer() {
            const question = questions[currentQuestion];
            
            switch(question.type) {
                case 'multiple-choice':
                    return question.options[selectedAnswer];
                case 'true-false':
                    return selectedAnswer ? 'True' : 'False';
                case 'drag-drop':
                    if (question.correctOrder) {
                        return question.dropZones.map((zone, index) => {
                            const itemIndex = dragDropAnswers[index];
                            return `${zone}: ${itemIndex !== undefined ? question.dragItems[itemIndex] : 'Empty'}`;
                        }).join(', ');
                    } else {
                        return question.dragItems.map((item, index) => {
                            const zoneIndex = dragDropAnswers[Object.keys(dragDropAnswers).find(key => dragDropAnswers[key] == index)];
                            return `${item}: ${zoneIndex !== undefined ? question.dropZones[zoneIndex] : 'Not assigned'}`;
                        }).join(', ');
                    }
                case 'matching':
                    return question.leftItems.map((item, index) => {
                        const rightIndex = matchingAnswers[index];
                        return `${item} → ${rightIndex !== undefined ? question.rightItems[rightIndex] : 'Not matched'}`;
                    }).join(', ');
                case 'fill-blank':
                    return fillBlankAnswers.join(', ');
            }
        }

        function getCorrectAnswer(question) {
            switch(question.type) {
                case 'multiple-choice':
                    return question.options[question.correct];
                case 'true-false':
                    return question.correct ? 'True' : 'False';
                case 'drag-drop':
                    if (question.correctOrder) {
                        return question.dropZones.map((zone, index) => {
                            return `${zone}: ${question.dragItems[question.correctOrder[index]]}`;
                        }).join(', ');
                    } else {
                        return question.dragItems.map((item, index) => {
                            return `${item}: ${question.dropZones[question.correctAssignment[index]]}`;
                        }).join(', ');
                    }
                case 'matching':
                    return question.leftItems.map((item, index) => {
                        return `${item} → ${question.rightItems[question.correctMatches[index]]}`;
                    }).join(', ');
                case 'fill-blank':
                    return question.blanks.join(', ');
            }
        }

        function nextQuestion() {
            if (currentQuestion < questions.length - 1) {
                currentQuestion++;
                selectedAnswer = null;
                dragDropAnswers = {};
                matchingAnswers = {};
                fillBlankAnswers = [];
                selectedLeftItem = null;
                showQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            document.getElementById('questionScreen').style.display = 'none';
            document.getElementById('resultScreen').style.display = 'block';
            
            // Calculate score and percentage
            const percentage = Math.round((score / questions.length) * 100);
            
            // Set score display
            document.getElementById('finalScore').textContent = `${score}/${questions.length}`;
            document.getElementById('correctAnswers').textContent = score;
            document.getElementById('wrongAnswers').textContent = questions.length - score;
            document.getElementById('percentage').textContent = `${percentage}%`;
            
            // Set feedback message
            const feedback = document.getElementById('feedbackMessage');
            if (percentage >= 90) {
                feedback.textContent = 'Tahniah! Anda sangat memahami konsep pemikiran komputasional!';
                feedback.className = 'feedback excellent';
            } else if (percentage >= 70) {
                feedback.textContent = 'Bagus! Anda memahami kebanyakan konsep tetapi ada ruang untuk penambahbaikan.';
                feedback.className = 'feedback good';
            } else {
                feedback.textContent = 'Anda perlu mengulangkaji beberapa konsep asas pemikiran komputasional.';
                feedback.className = 'feedback average';
            }
            
            // Update progress bar to 100%
            document.getElementById('progressBar').style.width = '100%';
        }

        function restartQuiz() {
            document.getElementById('resultScreen').style.display = 'none';
            startQuiz();
        }
    </script>
</body>
</html>
